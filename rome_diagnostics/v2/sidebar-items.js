window.SIDEBAR_ITEMS = {"derive":[["Diagnostic",""]],"fn":[["set_bottom_frame","Registers a function pointer as the “bottom frame” for this thread: all instances of [Backtrace] created on this thread will omit this function and all entries below it on the stack"]],"macro":[["category","The `category!` macro can be used to statically lookup a category by name from the registry"],["category_concat","The `category_concat!` macro is a variant of `category!` using a slightly different syntax, for use in the `declare_group` and `declare_rule` macros in the analyzer"]],"mod":[["adapters","This modules exposes a number of “adapter diagnostics” that wrap error types such as [std::error::Error] or [std::io::Error] in newtypes implementing the [Diagnostic] trait"],["advice",""],["context",""],["diagnostic",""],["display",""],["error","The `error` module contains the implementation of [Error], a dynamic container struct for any type implementing [Diagnostic]."],["location",""],["prelude","Anonymously re-exports all the traits declared by this module, this is intended to be imported as `use rome_diagnostics::v2::prelude::*;` to automatically bring all these traits into the ambient context"],["serde",""]],"struct":[["Backtrace","The [Backtrace] type can be used to capture a native Rust stack trace, to be displayed a diagnostic advice for native errors."],["Category","Metadata for a diagnostic category"],["MessageAndDescription","Convenient type that can be used when message and descriptions match, and they need to be displayed using different formatters"]]};