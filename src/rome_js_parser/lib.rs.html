<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `crates/rome_js_parser/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../rome_js_parser/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../rome_js_parser/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../rome_js_parser/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
</pre><pre class="rust"><code><span class="doccomment">//! Extremely fast, lossless, and error tolerant JavaScript Parser.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The parser uses an abstraction over non-whitespace tokens.</span>
<span class="doccomment">//! This allows us to losslessly or lossly parse code without requiring explicit handling of whitespace.</span>
<span class="doccomment">//! The parser yields events, not an AST, the events are resolved into untyped syntax nodes, which can then</span>
<span class="doccomment">//! be casted into a typed AST.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The parser is able to produce a valid AST from **any** source code.</span>
<span class="doccomment">//! Erroneous productions are wrapped into `ERROR` syntax nodes, the original source code</span>
<span class="doccomment">//! is completely represented in the final syntax nodes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! You probably do not want to use the parser struct, unless you want to parse fragments of Js source code or make your own productions.</span>
<span class="doccomment">//! Instead use functions such as [parse_script], [parse_module], and [] which offer abstracted versions for parsing.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Notable features of the parser are:</span>
<span class="doccomment">//! - Extremely fast parsing and lexing through the extremely fast lexer.</span>
<span class="doccomment">//! - Ability to do Lossy or Lossless parsing on demand without explicit whitespace handling.</span>
<span class="doccomment">//! - Customizable, able to parse any fragments of JS code at your discretion.</span>
<span class="doccomment">//! - Completely error tolerant, able to produce an AST from any source code.</span>
<span class="doccomment">//! - Zero cost for converting untyped nodes to a typed AST.</span>
<span class="doccomment">//! - Ability to go from AST to SyntaxNodes to SyntaxTokens to source code and back very easily with nearly zero cost.</span>
<span class="doccomment">//! - Very easy tree traversal through [`SyntaxNode`](rome_rowan::SyntaxNode).</span>
<span class="doccomment">//! - Descriptive errors with multiple labels and notes.</span>
<span class="doccomment">//! - Very cheap cloning, cloning an ast node or syntax node is the cost of adding a reference to an Rc.</span>
<span class="doccomment">//! - Cheap incremental reparsing of changed text.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The crate further includes utilities such as:</span>
<span class="doccomment">//! - ANSI syntax highlighting of nodes or text through `lexer`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! It is inspired by the rust analyzer parser but adapted for JavaScript.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Syntax Nodes vs AST Nodes</span>
<span class="doccomment">//! The crate relies on a concept of untyped [rome_js_syntax::JsSyntaxNode]s vs typed [rome_rowan::AstNode]s.</span>
<span class="doccomment">//! Syntax nodes represent the syntax tree in an untyped way. They represent a location in an immutable</span>
<span class="doccomment">//! tree with two pointers. The syntax tree is composed of [rome_js_syntax::JsSyntaxNode]s and [rome_js_syntax::JsSyntaxToken]s in a nested</span>
<span class="doccomment">//! tree structure. Each node can have parents, siblings, children, descendants, etc.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! [rome_rowan::AstNode]s represent a typed version of a syntax node. They have the same exact representation as syntax nodes</span>
<span class="doccomment">//! therefore a conversion between either has zero runtime cost. Every piece of data of an ast node is optional,</span>
<span class="doccomment">//! this is due to the fact that the parser is completely error tolerant.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Each representation has its advantages:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### SyntaxNodes</span>
<span class="doccomment">//! - Very simple traversing of the syntax tree through functions on them.</span>
<span class="doccomment">//! - Easily able to convert to underlying text, range, or tokens.</span>
<span class="doccomment">//! - Contain all whitespace bound to the underlying production (in the case of lossless parsing).</span>
<span class="doccomment">//! - Can be easily converted into its typed representation with zero cost.</span>
<span class="doccomment">//! - Can be turned into a pretty representation with fmt debug.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### AST Nodes</span>
<span class="doccomment">//! - Easy access to properties of the underlying production.</span>
<span class="doccomment">//! - Zero cost conversion to a syntax node.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! In conclusion, the use of both representations means we are not constrained to acting through</span>
<span class="doccomment">//! typed nodes. Which makes traversal hard and you often have to resort to autogenerated visitor patterns.</span>
<span class="doccomment">//! AST nodes are simply a way to easily access subproperties of a syntax node.event;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Authoring Parse Rules</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! This is a short, or not so short, guide to implement parse rules using the Rome parser infrastructure.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Naming</span>
<span class="doccomment">//! The convention is to prefix your parse rule with `parse_` and then use the name defined in the grammar file.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! For example, `parse_for_statement` or `parse_expression`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Signature</span>
<span class="doccomment">//! Most parse rules take a `&amp;mut` reference to the parser as their only parameter and return a `ParsedSyntax`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust,ignore</span>
<span class="doccomment">//! fn parse_rule_name(&amp;mut: Parser) -&gt; ParsedSyntax {}</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! You&#39;re free to add additional parameters to your function if needed. There are rare cases where you want to consider returning `ConditionalParsedSyntax` as explained in [conditional syntax](#conditional-syntax)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Parsing a single node</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Let&#39;s assume you want to parse the JS `if` statement:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```js</span>
<span class="doccomment">//! JsIfStatement =</span>
<span class="doccomment">//!  if</span>
<span class="doccomment">//!  (</span>
<span class="doccomment">//!  test: JsAnyExpression</span>
<span class="doccomment">//!  )</span>
<span class="doccomment">//!  consequent: JsBlockStatement</span>
<span class="doccomment">//!  else_clause: JsElseClause?</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Presence Test</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Now, the parsing function must first test if the parser is positioned at an `if` statement and return `Absent` if that&#39;s not the case.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! if !p.at(T![if]) {</span>
<span class="doccomment">//!  return ParsedSyntax::Absent;</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Why return `ParsedSyntax::Absent`? The function must return `ParsedSyntax::Absent` if the rule can&#39;t predict by the next token(s) if they form the expected node or not. Doing so allows the calling rule to decide if this is an error and perform an error recovery if necessary.  The second reason is to ensure that the rule doesn&#39;t return a node where all children are missing.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Your rule implementation may want to consider more than just the first child to determine if it can parse at least some of the expected children.</span>
<span class="doccomment">//! For example, the if statement rule could test if the parser is located at an `else` clause and then create an `if` statement where all children are missing except the `else` clause:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! if !p.at(T![if]) &amp;&amp; !p.at(T![else]){</span>
<span class="doccomment">//!   return Absent</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Your implementation can also call into another parsing rule if the first child is a node and not a token.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! let assignment_target = parse_assignment_target(p);</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! if assignment_target.is_absent() {</span>
<span class="doccomment">//!   return Absent;</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! let my_node = assignment_target.precede_or_missing();</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! But be careful with calling other rules. Your rule mustn&#39;t progress the parser - meaning that it can&#39;t</span>
<span class="doccomment">//! advance in the parsing process and consume tokens - if it returns `Absent`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Parse children</span>
<span class="doccomment">//! The parse rules will guide you in how to write your implementation and the parser infrastructure provides the following convenience APIs:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * Optional token `&#39;ident&#39;?`: Use `p.eat(token)`. It eats the next token if it matches the passed-in token.</span>
<span class="doccomment">//! * Required token `&#39;ident&#39;`: Use`p.expect(token)`. It eats the next token if it matches the passed-in token.</span>
<span class="doccomment">//! It adds an `Expected &#39;x&#39; but found &#39;y&#39; instead` error and a missing marker if the token isn&#39;t present in the source code.</span>
<span class="doccomment">//! * Optional node `body: JsBlockStatement?`: Use`parse_block_statement(p).or_missing(p)`. It parses the block if it is present in the source code and adds a missing marker if it isn&#39;t.</span>
<span class="doccomment">//! * Required node `body: JsBlockStatement`: Use `parse_block_statement(p).or_missing_with_error(p, error_builder)`:</span>
<span class="doccomment">//! it parses the block statement if it is present in the source code and adds a missing marker and an error if not.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Using the above-described rules result in the following implementation for the `if` statement rule.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! fn parse_if_statement(p: &amp;mut Parser) -&gt; ParsedSyntax {</span>
<span class="doccomment">//!  if !p.at(T![if]) {</span>
<span class="doccomment">//!   return Absent;</span>
<span class="doccomment">//!  }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  let m = p.start();</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  p.expect(T![if]);</span>
<span class="doccomment">//!  p.expect(T![&#39;(&#39;]);</span>
<span class="doccomment">//!  parse_any_expression(p).or_add_diagnostic(p, js_parse_errors::expeced_if_statement);</span>
<span class="doccomment">//!  p.expect(T![&#39;)&#39;]);</span>
<span class="doccomment">//!  parse_block_statement(p).or_add_diagnostic(p, js_parse_errors::expected_block_statement);</span>
<span class="doccomment">//! // the else block is optional, handle the marker by using `ok`</span>
<span class="doccomment">//!  parse_else_clause(p).ok();</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  Present(m.complete(p, JS_IF_STATEMENT));</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Hold on, what are these *missing* markers? Rome&#39;s AST facade uses fixed offsets to retrieve a particular child from a node.</span>
<span class="doccomment">//! For example, the 3rd child of the if statement is the condition. However, the condition would become the second element</span>
<span class="doccomment">//! if the opening parentheses `(` isn&#39;t present in the source text. That&#39;s where missing elements come into play.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Parsing Lists &amp; Error Recovery</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Parsing lists is different from parsing single elements with a fixed set of children because it requires looping until</span>
<span class="doccomment">//! the parser reaches a terminal token (or the end of the file).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! You may remember that `parse_*` methods shouldn&#39;t progress parsing if they return `Absent`.</span>
<span class="doccomment">//! Not progressing the parser is problematic inside `while` loops because it inevitably results in an infinite loop.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! That&#39;s why you must do error recovery when parsing lists. Luckily, the parser comes with the infrastructure to make error recovery a piece of cake.</span>
<span class="doccomment">//! The general structure for parsing a list is (yes, that&#39;s something the parser infrastructure should provide for you):</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Let&#39;s try to parse an array:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```js</span>
<span class="doccomment">//! [ 1, 3, 6 ]</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! We will use  `ParseSeparatedList` in order to achieve that</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! struct ArrayElementsList;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! impl ParseSeparatedList for ArrayElementsList {</span>
<span class="doccomment">//!     type ParsedElement = CompletedMarker;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     fn parse_element(&amp;mut self, p: &amp;mut Parser) -&gt; ParsedSyntax&lt;Self::ParsedElement&gt; {</span>
<span class="doccomment">//!         parse_array_element(p)</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     fn is_at_list_end(&amp;self, p: &amp;mut Parser) -&gt; bool {</span>
<span class="doccomment">//!         p.at_ts(token_set![T![default], T![case], T![&#39;}&#39;]])</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     fn recover(</span>
<span class="doccomment">//!         &amp;mut self,</span>
<span class="doccomment">//!         p: &amp;mut Parser,</span>
<span class="doccomment">//!         parsed_element: ParsedSyntax&lt;Self::ParsedElement&gt;,</span>
<span class="doccomment">//!     ) -&gt; parser::RecoveryResult {</span>
<span class="doccomment">//!         parsed_element.or_recover(</span>
<span class="doccomment">//!             p,</span>
<span class="doccomment">//!             &amp;ParseRecovery::new(JS_UNKNOWN_STATEMENT, STMT_RECOVERY_SET),</span>
<span class="doccomment">//!             js_parse_error::expected_case,</span>
<span class="doccomment">//!         )</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! };</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Let&#39;s run through this step by step:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! parsed_element.or_recover(</span>
<span class="doccomment">//!     p,</span>
<span class="doccomment">//!     &amp;ParseRecovery::new(JS_UNKNOWN_STATEMENT, STMT_RECOVERY_SET),</span>
<span class="doccomment">//!     js_parse_error::expected_case,</span>
<span class="doccomment">//! )</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The `or_recover` performs an error recovery if the `parse_array_element` method returns `Absent`;</span>
<span class="doccomment">//! there&#39;s no array element in the source text.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The recovery eats all tokens until it finds one of the tokens specified in the `token_set`,</span>
<span class="doccomment">//! a line break (if you called `enable_recovery_on_line_break`) or the end of the file.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The recovery doesn&#39;t throw the tokens away but instead wraps them inside a `UNKNOWN_JS_EXPRESSION` node (first parameter).</span>
<span class="doccomment">//! There exist multiple `UNKNOWN_*` nodes. You must consult the grammar to understand which `UNKNOWN*` node is supported in your case.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! &gt; You usually want to include the terminal token ending your list, the element separator token, and the token terminating a statement in your recovery set.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Now, the problem with recovery is that it can fail, and there are two reasons:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - the parser reached the end of the file;</span>
<span class="doccomment">//! - the next token is one of the tokens specified in the recovery set, meaning there is nothing to recover from;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! In these cases the `ParseSeparatedList` and `ParseNodeList` will recover the parser for you.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Conditional Syntax</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The conditional syntax allows you to express that some syntax may not be valid in all source files. Some use cases are:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * syntax that is only supported in strict or sloppy mode: for example, `with` statements is not valid when a JavaScript file uses `&quot;use strict&quot;` or is a module;</span>
<span class="doccomment">//! * syntax that is only supported in certain file types: Typescript, JSX, modules;</span>
<span class="doccomment">//! * syntax that is only available in specific language versions: experimental features, different versions of the language e.g. (ECMA versions for JavaScript);</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The idea is that the parser always parses the syntax regardless of whatever it is supported in this specific file or context.</span>
<span class="doccomment">//! The main motivation behind doing so is that this gives us perfect error recovery and allows us to use the same code regardless of whether the syntax is supported.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! However, conditional syntax must be handled because we want to add a diagnostic if the syntax isn&#39;t supported for the current file, and the parsed tokens must be attached somewhere.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Let&#39;s have a look at the `with` statement that is only allowed in loose mode/sloppy mode:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! fn parse_with_statement(p: &amp;mut Parser) -&gt; ParsedSyntax {</span>
<span class="doccomment">//!  if !p.at(T![with]) {</span>
<span class="doccomment">//!   return Absent;</span>
<span class="doccomment">//!  }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  let m = p.start();</span>
<span class="doccomment">//!  p.bump(T![with]); // with</span>
<span class="doccomment">//!  parenthesized_expression(p).or_add_diagnostic(p, js_errors::expected_parenthesized_expression);</span>
<span class="doccomment">//!  parse_statement(p).or_add_diagnostic(p, js_error::expected_statement);</span>
<span class="doccomment">//!  let with_stmt = m.complete(p, JS_WITH_STATEMENT);</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  let conditional = StrictMode.excluding_syntax(p, with_stmt, |p, marker| {</span>
<span class="doccomment">//!   p.err_builder(&quot;`with` statements are not allowed in strict mode&quot;)</span>
<span class="doccomment">//!    .primary(marker.range(p), &quot;&quot;)</span>
<span class="doccomment">//!  });</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  </span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The start of the rule is the same as for any other rule. The exciting bits start with</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust, ignore</span>
<span class="doccomment">//! let conditional = StrictMode.excluding_syntax(p, with_stmt, |p, marker| {</span>
<span class="doccomment">//!  p.err_builder(&quot;`with` statements are not allowed in strict mode&quot;)</span>
<span class="doccomment">//!   .primary(marker.range(p), &quot;&quot;)</span>
<span class="doccomment">//! });</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The `StrictMode.excluding_syntax` converts the parsed syntax to an unknown node and uses the diagnostic builder to create a diagnostic if the feature is not supported.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! You can convert the `ConditionalParsedSyntax` to a regular `ParsedSyntax` by calling `or_invalid_to_unknown`, which wraps the whole parsed `with` statement in an `UNKNOWN` node if the parser is in strict mode and otherwise returns the unchanged `with` statement.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! What if there&#39;s no `UNKNOWN` node matching the node of your parse rule? You must then return the `ConditionalParsedSyntax` without making the `or_invalid_to_unknown` recovery. It&#39;s then up to the caller to recover the potentially invalid syntax.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Summary</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! * Parse rules are named `parse_rule_name`</span>
<span class="doccomment">//! * The parse rules should return a `ParsedSyntax`</span>
<span class="doccomment">//! * The rule must return `Present` if it consumes any token and, therefore, can parse the node with at least some of its children.</span>
<span class="doccomment">//! * It returns `Absent` otherwise and must not progress parsing nor add any errors.</span>
<span class="doccomment">//! * Lists must perform error recovery to avoid infinite loops.</span>
<span class="doccomment">//! * Consult the grammar to identify the `UNKNOWN` node that is valid in the context of your rule.</span>

<span class="kw">mod</span> <span class="ident">parser</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">mod</span> <span class="ident">token_set</span>;
<span class="kw">mod</span> <span class="ident">event</span>;
<span class="kw">mod</span> <span class="ident">lexer</span>;
<span class="kw">mod</span> <span class="ident">lossless_tree_sink</span>;
<span class="kw">mod</span> <span class="ident">parse</span>;
<span class="kw">mod</span> <span class="ident">state</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">test</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;tests&quot;</span>))]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">test_utils</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span>;

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">syntax</span>;
<span class="kw">mod</span> <span class="ident">token_source</span>;

<span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span>::{
    <span class="ident">event</span>::{<span class="ident">process</span>, <span class="ident">Event</span>},
    <span class="ident">lexer</span>::{<span class="ident">LexContext</span>, <span class="ident">ReLexContext</span>},
    <span class="ident">lossless_tree_sink::LosslessTreeSink</span>,
    <span class="ident">parse</span>::<span class="kw-2">*</span>,
    <span class="ident">token_set::TokenSet</span>,
};
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use</span> <span class="ident">parser</span>::{<span class="ident">Checkpoint</span>, <span class="ident">CompletedMarker</span>, <span class="ident">Marker</span>, <span class="ident">ParseRecovery</span>, <span class="ident">Parser</span>};
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use</span> <span class="ident">state</span>::{<span class="ident">ParserState</span>, <span class="ident">StrictMode</span>};
<span class="kw">use</span> <span class="ident">std::fmt::Debug</span>;

<span class="doccomment">/// The type of error emitted by the parser, this includes warnings, notes, and errors.</span>
<span class="doccomment">/// It also includes labels and possibly notes</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ParseDiagnostic</span> <span class="op">=</span> <span class="ident">rome_diagnostics::Diagnostic</span>;

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::parser::ToDiagnostic</span>;
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::parser</span>::{<span class="ident">ParseNodeList</span>, <span class="ident">ParseSeparatedList</span>, <span class="ident">ParsedSyntax</span>};
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::ParsedSyntax</span>::{<span class="ident">Absent</span>, <span class="ident">Present</span>};
<span class="kw">use</span> <span class="ident">rome_diagnostics::Diagnostic</span>;
<span class="kw">use</span> <span class="ident">rome_js_syntax</span>::{<span class="ident">JsSyntaxKind</span>, <span class="ident">LanguageVariant</span>};
<span class="kw">use</span> <span class="ident">rome_rowan::TextSize</span>;

<span class="doccomment">/// An abstraction for syntax tree implementations</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">TreeSink</span> {
    <span class="doccomment">/// Adds new token to the current branch.</span>
    <span class="kw">fn</span> <span class="ident">token</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">kind</span>: <span class="ident">JsSyntaxKind</span>, <span class="ident">end</span>: <span class="ident">TextSize</span>);

    <span class="doccomment">/// Start new branch and make it current.</span>
    <span class="kw">fn</span> <span class="ident">start_node</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">kind</span>: <span class="ident">JsSyntaxKind</span>);

    <span class="doccomment">/// Finish current branch and restore previous</span>
    <span class="doccomment">/// branch as current.</span>
    <span class="kw">fn</span> <span class="ident">finish_node</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);

    <span class="doccomment">/// Emit errors</span>
    <span class="kw">fn</span> <span class="ident">errors</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">errors</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ParseDiagnostic</span><span class="op">&gt;</span>);
}

<span class="doccomment">/// A syntax feature that may or may not be supported depending on the file type and parser configuration</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">trait</span> <span class="ident">SyntaxFeature</span>: <span class="ident">Sized</span> {
    <span class="doccomment">/// Returns `true` if the current parsing context supports this syntax feature.</span>
    <span class="kw">fn</span> <span class="ident">is_supported</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">Parser</span>) -&gt; <span class="ident">bool</span>;

    <span class="doccomment">/// Returns `true` if the current parsing context doesn&#39;t support this syntax feature.</span>
    <span class="kw">fn</span> <span class="ident">is_unsupported</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">Parser</span>) -&gt; <span class="ident">bool</span> {
        <span class="op">!</span><span class="self">self</span>.<span class="ident">is_supported</span>(<span class="ident">p</span>)
    }

    <span class="doccomment">/// Adds a diagnostic and changes the kind of the node to [SyntaxKind::to_unknown] if this feature isn&#39;t</span>
    <span class="doccomment">/// supported.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Returns the parsed syntax.</span>
    <span class="kw">fn</span> <span class="ident">exclusive_syntax</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">E</span>, <span class="ident">D</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Parser</span>, <span class="ident">syntax</span>: <span class="ident">S</span>, <span class="ident">error_builder</span>: <span class="ident">E</span>) -&gt; <span class="ident">ParsedSyntax</span>
    <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">ParsedSyntax</span><span class="op">&gt;</span>,
        <span class="ident">E</span>: <span class="ident">FnOnce</span>(<span class="kw-2">&amp;</span><span class="ident">Parser</span>, <span class="kw-2">&amp;</span><span class="ident">CompletedMarker</span>) -&gt; <span class="ident">D</span>,
        <span class="ident">D</span>: <span class="ident">ToDiagnostic</span>,
    {
        <span class="ident">syntax</span>.<span class="ident">into</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">mut</span> <span class="ident">syntax</span><span class="op">|</span> {
            <span class="kw">if</span> <span class="self">self</span>.<span class="ident">is_unsupported</span>(<span class="ident">p</span>) {
                <span class="kw">let</span> <span class="ident">error</span> <span class="op">=</span> <span class="ident">error_builder</span>(<span class="ident">p</span>, <span class="kw-2">&amp;</span><span class="ident">syntax</span>);
                <span class="ident">p</span>.<span class="ident">error</span>(<span class="ident">error</span>);
                <span class="ident">syntax</span>.<span class="ident">change_to_unknown</span>(<span class="ident">p</span>);
                <span class="ident">syntax</span>
            } <span class="kw">else</span> {
                <span class="ident">syntax</span>
            }
        })
    }

    <span class="doccomment">/// Parses a syntax and adds a diagnostic and changes the kind of the node to [SyntaxKind::to_unknown] if this feature isn&#39;t</span>
    <span class="doccomment">/// supported.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Returns the parsed syntax.</span>
    <span class="kw">fn</span> <span class="ident">parse_exclusive_syntax</span><span class="op">&lt;</span><span class="ident">P</span>, <span class="ident">E</span><span class="op">&gt;</span>(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="ident">p</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Parser</span>,
        <span class="ident">parse</span>: <span class="ident">P</span>,
        <span class="ident">error_builder</span>: <span class="ident">E</span>,
    ) -&gt; <span class="ident">ParsedSyntax</span>
    <span class="kw">where</span>
        <span class="ident">P</span>: <span class="ident">FnOnce</span>(<span class="kw-2">&amp;mut</span> <span class="ident">Parser</span>) -&gt; <span class="ident">ParsedSyntax</span>,
        <span class="ident">E</span>: <span class="ident">FnOnce</span>(<span class="kw-2">&amp;</span><span class="ident">Parser</span>, <span class="kw-2">&amp;</span><span class="ident">CompletedMarker</span>) -&gt; <span class="ident">Diagnostic</span>,
    {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">is_supported</span>(<span class="ident">p</span>) {
            <span class="ident">parse</span>(<span class="ident">p</span>)
        } <span class="kw">else</span> {
            <span class="kw">let</span> <span class="ident">diagnostics_checkpoint</span> <span class="op">=</span> <span class="ident">p</span>.<span class="ident">diagnostics</span>.<span class="ident">len</span>();
            <span class="kw">let</span> <span class="ident">syntax</span> <span class="op">=</span> <span class="ident">parse</span>(<span class="ident">p</span>);
            <span class="ident">p</span>.<span class="ident">diagnostics</span>.<span class="ident">truncate</span>(<span class="ident">diagnostics_checkpoint</span>);

            <span class="kw">match</span> <span class="ident">syntax</span> {
                <span class="ident">Present</span>(<span class="kw-2">mut</span> <span class="ident">syntax</span>) =&gt; {
                    <span class="kw">let</span> <span class="ident">diagnostic</span> <span class="op">=</span> <span class="ident">error_builder</span>(<span class="ident">p</span>, <span class="kw-2">&amp;</span><span class="ident">syntax</span>);
                    <span class="ident">p</span>.<span class="ident">error</span>(<span class="ident">diagnostic</span>);
                    <span class="ident">syntax</span>.<span class="ident">change_to_unknown</span>(<span class="ident">p</span>);
                    <span class="ident">Present</span>(<span class="ident">syntax</span>)
                }
                <span class="kw">_</span> =&gt; <span class="ident">Absent</span>,
            }
        }
    }

    <span class="doccomment">/// Adds a diagnostic and changes the kind of the node to [SyntaxKind::to_unknown] if this feature is</span>
    <span class="doccomment">/// supported.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Returns the parsed syntax.</span>
    <span class="kw">fn</span> <span class="ident">excluding_syntax</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">E</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Parser</span>, <span class="ident">syntax</span>: <span class="ident">S</span>, <span class="ident">error_builder</span>: <span class="ident">E</span>) -&gt; <span class="ident">ParsedSyntax</span>
    <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">ParsedSyntax</span><span class="op">&gt;</span>,
        <span class="ident">E</span>: <span class="ident">FnOnce</span>(<span class="kw-2">&amp;</span><span class="ident">Parser</span>, <span class="kw-2">&amp;</span><span class="ident">CompletedMarker</span>) -&gt; <span class="ident">Diagnostic</span>,
    {
        <span class="ident">syntax</span>.<span class="ident">into</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">mut</span> <span class="ident">syntax</span><span class="op">|</span> {
            <span class="kw">if</span> <span class="self">self</span>.<span class="ident">is_unsupported</span>(<span class="ident">p</span>) {
                <span class="ident">syntax</span>
            } <span class="kw">else</span> {
                <span class="kw">let</span> <span class="ident">error</span> <span class="op">=</span> <span class="ident">error_builder</span>(<span class="ident">p</span>, <span class="kw-2">&amp;</span><span class="ident">syntax</span>);
                <span class="ident">p</span>.<span class="ident">error</span>(<span class="ident">error</span>);
                <span class="ident">syntax</span>.<span class="ident">change_to_unknown</span>(<span class="ident">p</span>);
                <span class="ident">syntax</span>
            }
        })
    }
}

<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">JsSyntaxFeature</span> {
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">unused</span>)]</span>
    <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">alias</span> <span class="op">=</span> <span class="string">&quot;LooseMode&quot;</span>)]</span>
    <span class="ident">SloppyMode</span>,
    <span class="ident">StrictMode</span>,
    <span class="ident">TypeScript</span>,
    <span class="ident">Jsx</span>,
}

<span class="kw">impl</span> <span class="ident">SyntaxFeature</span> <span class="kw">for</span> <span class="ident">JsSyntaxFeature</span> {
    <span class="kw">fn</span> <span class="ident">is_supported</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">Parser</span>) -&gt; <span class="ident">bool</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">JsSyntaxFeature::SloppyMode</span> =&gt; <span class="ident">p</span>.<span class="ident">state</span>.<span class="ident">strict</span>().<span class="ident">is_none</span>(),
            <span class="ident">JsSyntaxFeature::StrictMode</span> =&gt; <span class="ident">p</span>.<span class="ident">state</span>.<span class="ident">strict</span>().<span class="ident">is_some</span>(),
            <span class="ident">JsSyntaxFeature::TypeScript</span> =&gt; <span class="ident">p</span>.<span class="ident">source_type</span>.<span class="ident">language</span>().<span class="ident">is_typescript</span>(),
            <span class="ident">JsSyntaxFeature::Jsx</span> =&gt; <span class="ident">p</span>.<span class="ident">source_type</span>.<span class="ident">variant</span>() <span class="op">==</span> <span class="ident">LanguageVariant::Jsx</span>,
        }
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="rome_js_parser" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0 (a55dd71d5 2022-09-19)" ></div></body></html>