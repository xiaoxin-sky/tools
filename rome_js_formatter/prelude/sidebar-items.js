window.SIDEBAR_ITEMS = {"constant":[["LINE_TERMINATORS",""]],"enum":[["FormatElement","Language agnostic IR for formatting source code."],["FormatError","Series of errors encountered during formatting"],["LineMode",""],["PrintMode",""],["Tag","A Tag marking the start and end of some content to which some special formatting should be applied."],["TagKind","The kind of a [Tag]."],["TrailingSeparator",""]],"fn":[["align","Aligns its content by indenting the content by `count` spaces."],["block_indent","Inserts a hard line break before and after the content and increases the indention level for the content by one."],["dedent","It reduces the indention for the given content depending on the closest [indent] or [align] parent element."],["dedent_to_root","It resets the indent document so that the content will be printed at the start of the line."],["dynamic_text","Creates a text from a dynamic string and a range of the input source"],["empty_line","A forced empty line. An empty line inserts enough line breaks in the output for the previous and next element to be separated by an empty line."],["expand_parent","IR element that forces the parent group to print in expanded mode."],["format","The `format` function takes an [`Arguments`] struct and returns the resulting formatting IR."],["format_dangling_comments","Formats the dangling comments of `node`."],["format_leading_comments","Formats the leading comments of `node`"],["format_once","Creates an inline `Format` object that can only be formatted once."],["format_only_if_breaks","Formats the given token only if the group does break and otherwise retains the token’s skipped token trivia."],["format_removed","Formats the skipped token trivia of a removed token and marks the token as tracked."],["format_replaced","Print out a `token` from the original source with a different `content`."],["format_suppressed_node","Format a node having formatter suppression comment applied to it"],["format_trailing_comments","Formats the trailing comments of `node`."],["format_trimmed_token","Formats a token without its skipped token trivia"],["format_unknown_node","Formats unknown nodes. The difference between this method  and `format_verbatim` is that this method doesn’t track nodes/tokens as [VerbatimKind::Verbatim]. They are just printed as they are."],["format_verbatim_node","“Formats” a node according to its original formatting in the source text. Being able to format a node “as is” is useful if a node contains syntax errors. Formatting a node with syntax errors has the risk that Rome misinterprets the structure of the code and formatting it could “mess up” the developers, yet incomplete, work or accidentally introduce new syntax errors."],["format_with","Creates an object implementing `Format` that calls the passed closure to perform the formatting."],["get_lines_before","Get the number of line breaks between two consecutive SyntaxNodes in the tree"],["get_lines_before_token",""],["group","Creates a logical `Group` around the content that should either consistently be printed on a single line or broken across multiple lines."],["hard_line_break","A forced line break that are always printed. A hard line break forces any enclosing `Group` to be printed over multiple lines."],["if_group_breaks","Adds a conditional content that is emitted only if it isn’t inside an enclosing `Group` that is printed on a single line. The element allows, for example, to insert a trailing comma after the last array element only if the array doesn’t fit on a single line."],["if_group_fits_on_line","Adds a conditional content specific for `Group`s that fit on a single line. The content isn’t emitted for `Group`s spanning multiple lines."],["indent","It adds a level of indentation to the given content"],["indent_if_group_breaks","Increases the indent level by one if the group with the specified id breaks."],["labelled","Marks some content with a label."],["line_suffix","Pushes some content to the end of the current line"],["line_suffix_boundary","Inserts a boundary for line suffixes that forces the printer to print all pending line suffixes. Helpful if a line sufix shouldn’t pass a certain point."],["normalize_newlines","Replace the line terminators matching the provided list with “\\n” since its the only line break type supported by the printer"],["soft_block_indent","Indents the content by inserting a line break before and after the content and increasing the indention level for the content by one if the enclosing group doesn’t fit on a single line. Doesn’t change the formatting if the enclosing group fits on a single line."],["soft_line_break","A line break that only gets printed if the enclosing `Group` doesn’t fit on a single line. It’s omitted if the enclosing `Group` fits on a single line. A soft line break is identical to a hard line break when not enclosed inside of a `Group`."],["soft_line_break_or_space","A line break if the enclosing `Group` doesn’t fit on a single line, a space otherwise."],["soft_line_indent_or_space","If the enclosing `Group` doesn’t fit on a single line, inserts a line break and indent. Otherwise, just inserts a space."],["soft_space_or_block_indent","Adds spaces around the content if its enclosing group fits on a line, otherwise indents the content and separates it by line breaks."],["space","Inserts a single space. Allows to separate different tokens."],["syntax_token_cow_slice","String that is the same as in the input source text if `text` is [`Cow::Borrowed`] or some replaced content if `text` is [`Cow::Owned`]."],["syntax_token_text_slice","Copies a source text 1:1 into the output text."],["text","Creates a token that gets written as is to the output. Make sure to properly escape the text if it’s user generated (e.g. a string and not a language keyword)."],["write","The `write` function takes a target buffer and an `Arguments` struct that can be precompiled with the `format_args!` macro."]],"macro":[["best_fitting","Provides multiple different alternatives and the printer picks the first one that fits. Use this as last resort because it requires that the printer must try all variants in the worst case. The passed variants must be in the following order:"],["dbg_write","Writes formatted data into the given buffer and prints all written elements for a quick and dirty debugging."],["format","Creates the Format IR for a value."],["format_args","Constructs the parameters for other formatting macros."],["write","Writes formatted data into a buffer."]],"mod":[["document",""],["tag",""]],"struct":[["Align",""],["BlockIndent",""],["Dedent",""],["Document","A formatted document."],["DynamicText",""],["ExpandParent",""],["FillBuilder","Builder to fill as many elements as possible on a single line."],["FormatLabelled",""],["FormatOnce",""],["FormatSeparatedOptions",""],["FormatWith","Utility for formatting some content with an inline lambda function."],["Formatter","Handles the formatting of a CST and stores the context how the CST should be formatted (user preferences). The formatter is passed to the [Format] implementation of every node in the CST so that they can use it to format their children."],["Group",""],["IfGroupBreaks",""],["Indent",""],["IndentIfGroupBreaks",""],["Interned",""],["JoinBuilder","Builder to join together a sequence of content. See [Formatter::join]"],["JoinNodesBuilder","Builder to join together nodes that ensures that nodes separated by empty lines continue to be separated by empty lines in the formatted output."],["LabelId",""],["Line",""],["LineSuffix",""],["LineSuffixBoundary",""],["Memoized","Memoizes the output of its inner [Format] to avoid re-formatting a potential expensive object."],["PrinterOptions","Options that affect how the [crate::Printer] prints the format tokens"],["SimpleFormatContext",""],["Space",""],["StaticText",""],["SyntaxTokenCowSlice",""],["SyntaxTokenTextSlice",""]],"trait":[["BufferExtensions",""],["Format","Formatting trait for types that can create a formatted representation. The `rome_formatter` equivalent to [std::fmt::Display]."],["FormatAstSeparatedListExtension","AST Separated list formatting extension methods"],["FormatElements",""],["FormatRule","Rule that knows how to format an object of type `T`."],["MemoizeFormat","Utility trait that allows memorizing the output of a [Format]. Useful to avoid re-formatting the same object twice."],["_","Utility trait used to simplify the formatting of optional objects that are formattable."]],"type":[["FormatResult","Public return type of the formatter"]]};